##轻量指针
C/C++最令人头痛的地方莫过于内存管理，所有new出来的对象必须有相应的delete，否则开辟出的内存并不会被释放，进而造成内存泄露。为了解决这个问题，最简单也是最直观的办法就是引入计数器。
每个对象自身维护着一个计数器，当有指针引用它时计数器加一，当有指针不再引用它时计数器减一。

这种最朴素的办法在android native层的实现就是LightRefBase和StrongPointer，源代码在[这里](https://github.com/android/platform_system_core/blob/a59c7bcc48121cd95f65f3a67560dc1d461fc85a/libutils/include/utils/RefBase.h#L349)。

其中LightRefBase是所有支持轻量指针的类的基类，它在内部维护了一个计数器，并提供方法操纵计数器。StrongPointer对应的就是轻量指针，当我们把LightRefBase赋值给StrongPointer时，StrongPointer会调用LightRefBase提供的方法，去增减计数器的值。

在这里我不解析源码，通过一个例子感性的认识一下使用轻量指针时它的内部发生了什么。

```
#include <stdio.h>
#include <utils/RefBase.h>

using namespace android;

class LightClass : public LightRefBase<LightClass>
{
public:
    LightClass()
    {
        printf("Construct LightClass");
    }

    virtual ~LightClass()
    {
        printf("Destory LightClass");
    }
};

int main(int argc, char** argv)
{
    LightClass* lightClass = new LightClass();
    LightClass* lightClassAgain = new LightClass();

    sp<LightClass> lp = lightClass;

    printf("lightClass Ref Count:%d.\n", lightClass->getStrongCount());
    printf("lightClassAgain Ref Count:%d.\n", lightClassAgain->getStrongCount());

    {
        sp<LightClass> lpAgain = lightClass;

        printf("lightClass Ref Count:%d.\n", lightClass->getStrongCount());
        printf("lightClassAgain Ref Count:%d.\n", lightClassAgain->getStrongCount());
    }

    printf("lightClass Ref Count:%d.\n", lightClass->getStrongCount());
    printf("lightClassAgain Ref Count:%d.\n", lightClassAgain->getStrongCount());

    lp = lightClassAgain;

    printf("lightClassAgain Ref Count:%d.\n", lightClassAgain->getStrongCount());

    return 0;
}
```
* 当我们创建lightClass，lightClassAgain，我们显然会在Console看到`Construct LightClass`, `Construct LightClass`。
* 当lp指向lightClass，此时lightClass内部的计数器会加1，我们会看到 `lightClass Ref Count: 1`, `lightClassAgain Ref Count: 0`。
* 当lpAgain指向lightClass，此时lightClass内部的计数器会加1，我们会看到 `lightClass Ref Count: 2`, `lightClassAgain Ref Count: 0`。
* 当lpAgain的作用域结束，lpAgain被释放时，lightClass内部的计数器会减1，我们会看到 `lightClass Ref Count: 1`, `lightClassAgain Ref Count: 0`。
* 当lp指向lightClassAgain，lightClass内部的计数器会减1变为0，这会导致lightClass的析构函数被调用，lightClassAgain内部的计数器会加1，我们会看到 `Destory LightClass`, `lightClassAgain Ref Count: 1`。
* 当lp指向lightClassAgain，lightClass内部的计数器会减1变为0，这会导致lightClass的析构函数被调用，lightClassAgain内部的计数器会加1，我们会看到 `Destory LightClass`, `lightClassAgain Ref Count: 1`。
